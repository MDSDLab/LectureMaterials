# Name analysis

The goal of name analysis is to connect name references with their definitions (e.g., for variables).

Xtext can do some name analysis using square brackets (`[...]`), however, the default behavior is not always sufficient. In these cases we need to lend some help to Xtest using [scoping](https://eclipse.dev/Xtext/documentation/303_runtime_concepts.html#scoping).

In addition, we need to provide error messages if there are problems with name definitions or name resolutions. The problems with name resolutions are automatically reported by Xtext, but the problems with name definitions (e.g., duplicate names) must be reported by us using [validation](https://eclipse.dev/Xtext/documentation/303_runtime_concepts.html#validation).

## Scoping

By default, Xtext tries to resolve names according to the structure of the code. However, in some cases this is insufficient. For example, in the WebTest language the `context as <page> ... end` construct must allow the resolution of variables and operations defined in the page, and Xtext cannot infer this from the structure of the code.

Inside the **webtest.dsl** project, under the folder **src** from the package **webtest.dsl.scoping** open the file **WebTestDslScopeProvider.java**, and modify its contents as follows:

```Java
/*
 * generated by Xtext 2.35.0
 */
package webtest.dsl.scoping;

import java.util.ArrayList;
import java.util.Arrays;

import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EReference;
import org.eclipse.xtext.scoping.IScope;
import org.eclipse.xtext.scoping.Scopes;

import webtest.model.BlockStatement;
import webtest.model.ContextStatement;
import webtest.model.ForEachStatement;
import webtest.model.Main;
import webtest.model.ModelPackage;
import webtest.model.Operation;
import webtest.model.Page;
import webtest.model.Statement;
import webtest.model.TestCase;
import webtest.model.Variable;
import webtest.model.VariableStatement;

/**
 * This class contains custom scoping description.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#scoping
 * on how and when to use it.
 */
public class WebTestDslScopeProvider extends AbstractWebTestDslScopeProvider {
  @Override
  public IScope getScope(EObject obj, EReference ref) {
    if (ref == ModelPackage.Literals.CALL_STATEMENT__OPERATION || ref == ModelPackage.Literals.VARIABLE_EXPRESSION__VARIABLE) {
      var scope = getScope(obj, ref, obj.eContainer());
      return scope;
    } else {
      return super.getScope(obj, ref);
    }
  }

  private IScope getScope(EObject obj, EReference ref, EObject container) {
    if (container == null) return IScope.NULLSCOPE;
    var scope = getScope(obj, ref, container.eContainer());
    if (ref == ModelPackage.Literals.CALL_STATEMENT__OPERATION) {
      if (container instanceof ContextStatement) {
        var context = (ContextStatement)container;
        if (context.getPage() != null) scope = Scopes.scopeFor(context.getPage().getOperations(), scope);
      }
      return scope;
    }
    if (ref == ModelPackage.Literals.VARIABLE_EXPRESSION__VARIABLE) {
      if (container instanceof Statement) {
        var candidates = new ArrayList<Variable>();
        var stmt = (Statement)container;
        if (stmt.eContainer() instanceof BlockStatement) {
          var block = (BlockStatement)stmt.eContainer();
          var index = block.getStatements().indexOf(stmt);
          for (var i = 0; i < index; i++) {
            var prevStmt = block.getStatements().get(i);
            if (prevStmt instanceof VariableStatement) {
              var varStmt = (VariableStatement)prevStmt;
              candidates.add(varStmt.getVariable());
            }
          }
        }
        scope = Scopes.scopeFor(candidates, scope);
      }
    }
    return scope;
  }  
}
```

The code above shows two examples:

* It allows the resolution of operations inside `context as`, which were defined in the context's **Page**. In addition, it also allows the resolution of operations from all other containing `context as` constructs, since the potential scopes are organized into a linked list (using **Scopes.scopeFor**). The inner contexts hide operations from the outer contexts, in case those operations have the same names.
* Statements can refer to variables only defined before the statement itself, and not after. Also, variables defined earlier in containing blocks are also available, again, due to the linked list organization of scopes.

In this task you have to develop this **WebTestDslScopeProvider** class further:

* Make variables of a **Page** of a `context as` construct available, and also from all other containing `context as` constructs. The inner contexts hide variables from the outer contexts, in case those variables have the same names.
* The parameters of an operation should be available inside the body of the operation.
* The variables and operations defined directly in a **Page** should be available in all operations inside the **Page**.
* If you have to implement the **ForEach** extension, make sure that the variable defined in the header of `foreach ... in ... end` is only available within the body of the `foreach` construct. Two `foreach` blocks next to each other can define the same variable name in their headers, but these variables are not the same!
* If you have to implement the **TestParams** extension, the parameters of the test should be available in the body of the test.

Be careful: while we edit a WebTest file, it is not always complete. There may be null values in the model built from the WebTest file even at places where you don't expect it. So make sure to check the model before accessing any property to avoid unwanted exceptions during scoping.

***HINT:** Inside the **getScope** function you can follow various strategies:*

* *You can ignore the **super** call by traversing all the containing objects and resolving references all in one go.*
* *You can call the **getScope** function recursively for the containing object (like in the example above). This way the responsibilities are distributed more evenly.*
* *You can use your own helper functions.*
* *For the correct handling of variables defined earlier, it is recommended to find the index of the current statement in the containing **BlockStatment**, and only make the variable definitions with smaller indices available in the scope (like in the example above).*

*To traverse the model, the following constructs can be helpful:*

* *The function **getContainerOfType** of the **EcoreUtil2** class gives the nearest container object of a given type.*
* *The function **getAllContainers** of the **EcoreUtil2** class gives all the direct and indirect container objects.*
* *The function **getAllContentsOfType** of the **EcoreUtil2** class gives all the directly or indirectly contained objects of a given type.*
* *Using **instanceof** can be useful, too.*

## Validation

If a name coult not be resolved, the error is reported automatically by Xtext. However, duplicate name definitions must be reported by us. We can do this using validators.

Inside the **webtest.dsl** project under the **src** folder in the **webtest.dsl.validation** package create a new file called **NameValidator.java** with the following content:

```Java
package webtest.dsl.validation;

import java.util.HashSet;

import org.eclipse.xtext.validation.Check;
import org.eclipse.xtext.validation.CheckType;
import org.eclipse.xtext.validation.EValidatorRegistrar;

import webtest.model.Main;
import webtest.model.ModelPackage;
import webtest.model.NamedElement;
import webtest.model.Page;

class NameValidator extends AbstractWebTestDslValidator {
  // This empty override is necessary to prevent reporting duplicate validation messages
  @Override
  public void register(EValidatorRegistrar registrar) {
  }

  @Check(CheckType.NORMAL)
  public void checkDuplicatePageNames(Main main) {
    try {
      var names = new HashSet<String>();
      for (NamedElement ne: main.getDeclarations()) {
        if (ne instanceof Page && ne.getName() != null && !names.add(ne.getName())) {
          error("Page '"+ne.getName()+"' is already defined.", ne, ModelPackage.Literals.NAMED_ELEMENT__NAME);
        }
      }
    } catch (Exception ex) {
      ex.printStackTrace();
    }
  }
}
```

The **checkDuplicatePageNames** function checks whether the names of the **Page** elements are unique. If not, it will report an error for the duplicate names: `Page '<name>' is already defined.`

The error message is reported on the name of the page: since **Page** is a descendant of **NamedElement**, the name of the page is represented by the property **name** of the **NamedElement** class.

The **@Check** annotation tells Xtext to call the **checkDuplicatePageNames** function during validation. The **NORMAL** parameter tells Xtext to check this condition when the WebTest code is saved. The single argument of the **checkDuplicatePageNames** function is the object on which the validation should be performed. In this case it is the root of the whole model (**Main**), since through this we can check all the **Page** objects inside the model. For other validations, the type of the parameter can defer from **Main**, and Xtext will call the validation for every possible object of the chosen type.

We have to do another step for Xtext to recognize our validator. Inside the **webtest.dsl** project under the **src** folder from the **webtest.dsl.scoping** package open **WebTestDslValidator.java*, and modify it as follows:

```Java
package webtest.dsl.validation;

import org.eclipse.xtext.validation.ComposedChecks;

/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
@ComposedChecks(validators = {NameValidator.class})
public class WebTestDslValidator extends AbstractWebTestDslValidator {

}
```

Since Xtext only registers the **WebTestDslValidator** validator automatically. Using the **@ComposedChecks** annotation on this class we can specify other validators for Xtext to take into account. Later, you will also register further validators here.

Develop the **NameValidator** class further:

* Report if test cases have duplicate names: `Test case '<name>' is already defined.`
* Report if variables have duplicate names: `Variable '<name>' is already defined.`
* Report if operations have duplicate names: `Operation '<name>' is already defined.`
* Report if operation parameters have duplicate names: `Parameter '<name>' is already defined.`
* Report if a local variable hides a parameter inside an operation: `Variable '<name>' is already defined.`
* Report if the number of arguments when calling an operation differs from the number of parameters of the operation: `Operation '<name>' has <parameter count> parameters but <argument count> arguments were specified.`
* If you have to implement the **ForEach** extension, report if a variable defined in the header of `foreach` collides with another local variable or parameter: `Variable '<name>' is already defined.`
* If you have to implement the **Manual** extension, report if the manuals have duplicate names: `Manual '<name>' is already defined.`
* If you have to implement the **TestParams** extension:

  * Report if the test parameters have duplicate names: `Parameter '<name>' is already defined.`
  * Report if a local variable hides a test parameter: `Variable '<name>' is already defined.`
  * Report if the number of arguments supplied after the `with` keyword differs from the number of parameters of the test: `Test case '<name>' has <parameter count> parameters but <argument count> arguments were specified.`

## Check the solution

You can check whether name resolution and scoping works correctly easily inside the **Runtime Eclipse**: click on a name while holding **Ctrl** down. Xtext will jump to the definition of the name.

Errors reported by the validators are marked by red underscores inside **.wt** files in **Runtime Eclipse**.

You can check your name analysis implementation using the **webtest.dsl.tests** project, by running it as a JUnit test (**Run as > JUnit Test**). The classes **NameAnalysisTests** and **NameAnalysisExtensionsTests** check the correctness of the name analysis.

## To be uploaded

During the solution of the task, take screen shots taken from the following parts, and upload them into the folder **homeworks/hw1** of your own git repo:

* The test summary window in **Eclipse** for the **webtest.model.tests** project, which shows that all the tests in **NameAnalysisTests** and **NameAnalysisExtensionsTests** are executed successfully. (For the success of the test **NameAnalysisTests.testLocalVariableErrors()** test the solution of type analysis task may be necessary.)
